# lf-pico-template
This repo is a template for [Lingua Franca](https://www.lf-lang.org/) projects using the baremetal RP2040 target platform. Currently the repo supports macos, linux and windows through [WSL](https://learn.microsoft.com/en-us/windows/wsl/install)
To support RP2040 based boards, the repo uses the [pico-sdk](https://github.com/raspberrypi/pico-sdk/tree/master/src)as a dependency which includes a light set of headers, libraries and a build system to interact with the mcu.

## Setup
The lf-pico-template uses nix to manage toolchains and other applications. Install [nix](https://nixos.org/download.html) first for your preferred platform. After installation, run the following in the shell to enable the experimental nix flakes feature.
``` bash
mkdir -p ~/.config/nix
echo "experimental-features = nix-command flakes" >> ~/.config/nix/nix.conf
```

To launch the lf-pico shell environment, run the following in the root of the lf-pico repository. The launched shell will include the various required toolchains and applications needed for development.
```bash
nix develop
```

## Building
Lingua Franca applications are code generated into the target language. To both code generate and build application binaries one can either use lfc or lingo. Lingo ultimately uses lfc as a backend but provides an additional experimental interface for managing multiple application binaries builds.

### LFC
LFC is the main lingua franca compiler used for code generation. Install a nightly version of the [tool chain](https://github.com/lf-lang/lingua-franca/releases/tag/nightly) since RP2040 support is not in an official release.

After installation, run ``lfc`` in the root directory on the application of your choice.
``` bash
lfc src/Blink.lf
```
An application binary will be populated in the ``/bin`` directory with the same name as the source file. The source code for the application after code generation will be in the ``/src-gen`` folder.

### Lingo
An alternative method for generating code and building is using Lingo. Lingo uses a a toml file to specify what applications to build and different target properties to assign them. Build artifacts are populated in the ``/target`` directory.

To build an application, add then application to the ``Lingo.toml`` file in the repository root.

After adding, run the following.
``` bash
lingo build
```

## Flashing
Before flashing the binary to your rp2040 based board, the board must be placed into ``BOOTSEL`` mode. On a [Raspberry Pi Pico](https://www.raspberrypi.com/products/raspberry-pi-pico/) this can be entered by holding the ``RESET`` button while connecting the board to the host device.

The [picotool](https://github.com/raspberrypi/picotool) application installed in the nix shell is an easy way to interact with boards.
With the application you can check what programs are currently flashed and can directly load program binaries. Run ``picotool help`` for more information on its capabilities.

Run the following to flash an application binary on to your board.
``` shell
picotool load bin/Blink.elf
```

## Debugging
Using GDB can be a challenge. That is all.



## Emulator
To run basic smoke tests and monitor GPIO, UART and other supported peripherals, a nodejs based emulator is provided in this repo. During the nix shell setup for the repo, the node modules in the ``/test`` directory are installed. 

These are the currently supported peripherals the emulator has integration with. More information can be found [here](https://docs.wokwi.com/parts/wokwi-pi-pico)
<table>
<thead><tr><th>Peripheral</th><th>Status</th><th>Notes</th></tr></thead><tbody><tr><td>Processor core</td><td>‚úîÔ∏è</td><td>Only a single core is simulated</td></tr><tr><td>GPIO</td><td>‚úîÔ∏è</td><td></td></tr><tr><td>PIO</td><td>‚úîÔ∏è</td><td>PIO Debugger available</td></tr><tr><td>USB</td><td>üü°</td><td>USB CDC (Serial) supported, see <a href="#serial-monitor">Serial Monitor</a> below</td></tr><tr><td>UART</td><td>‚úîÔ∏è</td><td></td></tr><tr><td>I2C</td><td>‚úîÔ∏è</td><td>Master mode only</td></tr><tr><td>SPI</td><td>‚úîÔ∏è</td><td>Master mode only</td></tr><tr><td>PWM</td><td>‚úîÔ∏è</td><td></td></tr><tr><td>DMA</td><td>‚úîÔ∏è</td><td>Only for the PIO peripheral</td></tr><tr><td>Timer</td><td>‚úîÔ∏è</td><td>Pausing the timer not implemented yet</td></tr><tr><td>ARM SysTick Timer</td><td>‚úîÔ∏è</td><td></td></tr><tr><td>Watchdog</td><td>‚ùå</td><td></td></tr><tr><td>RTC</td><td>‚ùå</td><td></td></tr><tr><td>ADC + Temp sensor</td><td>‚úîÔ∏è</td><td>Temperature sensor always reads 0</td></tr><tr><td>SSI</td><td>üü°</td><td>Just the minimum to make the bootloader happy</td></tr><tr><td>GDB Debugging</td><td>‚úîÔ∏è</td><td>See the <a href="/gdb-debugging">GDB Debugging guide</a></td></tr></tbody>
</table>


By default, the emulator uses **hex** binaries which are generated by both build options. Any hex files that are in need of testing must be placed in the ``/target/hex/`` directory. This will automatically be done by *lingo*.

Run the following from the ``/test/`` directory. It will run an emulator instance for each hex file in the ``hex`` directory in parallel and report results as plain text files.
``` bash
cd test/
npm start
```
The text framework source code is available and can be easily extended. Currently, a test is set to report a **FAILING** status if it does not terminate within 10 seconds but this condition can be altered.

